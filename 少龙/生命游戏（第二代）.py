#细胞用■来表示'''生命游戏(game of life)为1970年由英国数学家J. H. Conway所提出 某细胞的邻居包括上、下、左、右、左上、左下、右上与右下相邻之细胞 游戏规则如下：孤单死亡：如果细胞的邻居小于等于1个，则该细胞在下一次状态将死亡；拥挤死亡：如果细胞的邻居在4个及以上，则该细胞在下一次状态将死亡；稳定：如果细胞的邻居为2个或3个，则下一次状态为稳定存活；复活：如果某位置原无细胞存活，而该位置的邻居为3个，则该位置将复活一个细胞。'''from random import random#用于产生0~1之间的浮点型数据，控制每一个方格内第一代细胞的产生概率import  time#用于控制每一代细胞之间的生成间隔import os#用于清屏操作#定义输入错误的类型class SillyInputException(Exception):    pass#定义用户输入的坐标超过空间的错误类型class InputBeyondTheSpace(Exception):    pass#控制用户的输入规范class Input():    #开始游戏的输入    def enter_the_game(self):        q = int(input('开始游戏请输入：1。退出游戏请输入：2：'))        if q != 1 and q != 2:            raise SillyInputException('请按照输入提示进行正确的输入！')        return q    #演化空间大小的输入    def input_the_space(self):        n = int(input('请输入演化空间的大小（默认长宽比为1：1）：'))        if not isinstance(n,int):            raise SillyInputException('请按照输入提示进行正确的输入！')        elif n <= 0:            raise SillyInputException('请按照输入提示进行正确的输入！')        return n    #第一代细胞产生概率的输入    def input_the_probability(self):        m = float(input('请输入每个格子产生第一代细胞的概率（以小数形式表示）：'))        if m >= 1 or m <= 0:            raise SillyInputException('请按照输入提示进行正确的输入！')        return m    #演化次数的输入    def input_the_times(self):        t = int(input('请输入所需演化次数：'))        if not isinstance(t,int):            raise SillyInputException('请按照输入提示进行正确的输入！')        elif t <= 0:            raise SillyInputException('请按照输入提示进行正确的输入！')        return t    #控制每一代细胞之间的生成间隔的输入    def input_the_sleeptime(self):        sleeptime = float(input('请输入每代细胞产生的时间间隔：'))        if sleeptime <= 0:            raise SillyInputException('请按照输入提示进行正确的输入！')        return sleeptime    #是否进行自定义编辑的输入    def input_the_Custom_editing(self):        Custom_editing = int(input('若由电脑随机生成第一代细胞请按1，若自定义生成第一代细胞请按2：'))        if Custom_editing != 1 and Custom_editing != 2:            raise SillyInputException('请按照输入提示进行正确的输入！')        return Custom_editing#主程序：控制用户输入数据并调用函数def main():    global row    Item = Input()    print('本游戏由少龙（Loong）开发!')    while True:        try:            q = Item.enter_the_game()            if q == 1:                break            elif q == 2:                return        except SillyInputException as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    while True:        try:            n = Item.input_the_space()            break        except SillyInputException as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    while True:        try:            t = Item.input_the_times()            break        except SillyInputException as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    while True:        try:            sleeptime = Item.input_the_sleeptime()            break        except SillyInputException as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    while True:        try:            Custom_editing = Item.input_the_Custom_editing()            if Custom_editing == 1:                while True:                    try:                        m = Item.input_the_probability()                        space(n, m, sleeptime)                        break                    except SillyInputException as e:                        print(e)                    except ValueError:                        print('请按照输入提示进行正确的输入！')                break            elif Custom_editing == 2:                col = []                row = []                for i in range(0, n):                    for o in range(0, n):                        col.append('□')                    row.append(col)                    col = []                print_the_next_generation_cells(n)                while True:                    try:                        Order = 0                        Order = int(input('停止请输入1，继续输入细胞坐标请输入2：'))                        if Order == 1:                            break                        elif Order == 2:                            editing(n)                            print_the_next_generation_cells(n)                        else:                            raise SillyInputException('请按照输入提示进行正确的输入！')                    except SillyInputException as e:                        print(e)                    except ValueError:                        print('请按照输入提示进行正确的输入！')            break        except SillyInputException as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    #循环显示出下一代细胞    for F in range(0,t):        os.system('cls')        evolution(n)        print_the_next_generation_cells(n)        time.sleep(sleeptime)#打印出初始空间及第一代细胞def space(n,m,sleeptime):    os.system('cls')    global row    row = []#行    col = []#列    for i in range(0,n):        for o in range(0,n):            if random() <= m:                col.append('■')            else:                col.append('□')        row.append(col)        col = []    for i in range(0,n):        if i == 0:            print('—' * (n + 1))        for o in range(0,n):            if o == 0:                print('|',end='')            print(row[i][o],sep='',end='')            if o == n-1:                print('|')    print('—' * (n + 1))    time.sleep(sleeptime)#进行演化def evolution(n):    nearby = 0#将一个细胞周围的细胞的个数记录在此变量    nearbylist = []#用于储存一个细胞周围的细胞情况的列表    #死亡检测    for y in range(0,n):        for x in range(0,n):            try:                nearbylist.append(row[y + 1][x + 1])                nearbylist.append(row[y + 1][x])                nearbylist.append(row[y + 1][x - 1])                nearbylist.append(row[y][x + 1])                nearbylist.append(row[y][x - 1])                nearbylist.append(row[y - 1][x + 1])                nearbylist.append(row[y - 1][x])                nearbylist.append(row[y - 1][x - 1])                nearby = nearbylist.count('■')                if row[y][x] == '■':                    if nearby <= 1 or nearby >= 4:                        row[y][x] = '□'                        nearby = 0                        nearbylist = []                    else:                        nearby = 0                        nearbylist = []                        continue                elif row[y][x] == '□':                    if nearby == 3:                        row[y][x] = '■'                        nearby = 0                        nearbylist = []                    else:                        nearby = 0                        nearbylist = []                        continue            except IndexError:                pass#打印出下一代细胞def print_the_next_generation_cells(n):    for i_1 in range(0,n):        if i_1 == 0:            print('—' * (n + 1))        for o_1 in range(0,n):            if o_1 == 0:                print('|',end='')            print(row[i_1][o_1],sep='',end='')            if o_1 == n-1:                print('|')    print('—' * (n + 1))def editing(n):    while True:        try:            location_x = int(input('请输入细胞的坐标横坐标：'))            if location_x <= 0 or location_x > n:                raise InputBeyondTheSpace('输入的坐标须在在方才输入的空间中！')            else:                break        except InputBeyondTheSpace as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    while True:        try:            location_y = int(input('请输入细胞的坐标纵坐标：'))            if location_y <= 0 or location_y > n:                raise InputBeyondTheSpace('输入的坐标须在在方才输入的空间中！')            else:                break        except InputBeyondTheSpace as e:            print(e)        except ValueError:            print('请按照输入提示进行正确的输入！')    row[location_y - 1][location_x - 1] = '■'main()input()